---
layout: post
title:  "(N+1) Error"
date:   2021-06-17
tags: SpringBoot Mapping JPA
color: rgb(154,133,255)
subtitle: 'Spring Boot Mapping Error'
---
## Background
### 준영속 상태와 지연로딩
스프링 커테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다.
즉, 트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 같다는 뜻이다. 그리고
트랜잭션은 보통 서비스 계층에서 시작하므로 서비스 계층이 끝나는 시점에 트랜잭션이 종료되면서 영속성 컨텍스트로 함께 종료된다.

```java
@Entity
public class order{
    @Id @GeneratorValue
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    private Member member;
}
```

컨테이너 환경의 기본 전략인 트랜잭션 범위의 영속성 컨택스트 전략을 사용하면 트랜잭션이 없는 프래젠테이션 계층에서 엔티티는 준영속 상태다.
따라서 감지와 지연 로딩이 동작하지 않는다.

```java
class OrderController{
    public String view(Long orderId){
        Order order = orderService.findOne(orderId);
        Member member = order.getMember();
        member.getName(); // 지연로딩 시 예외 발생 
    }
}
```

* 준영속 상태와 변경 감지
**변경감지기능**은 영속성  컨텍스트가 살아있는 서비스 계틍까지만 동작하고 영속성 컨텍스트가 종료된 프레젠테이션 계층에서는 동작하지 않는다.
  
    (보통은 비즈니스 로직을 수행하면서 발생)
반대로 **변경감지기능**이 프레젠테이션 계층에서 동작하게 되면 책인이 모호해지고 유지보수가 어려워진다. 
  
* 준영속 상태외 지연로딩
준영속 상태의 가장 큰 문제점은 <u>지연로딩이 동작하지 않는다는 점이다.</u> 
  * 해결방법
    1. 뷰가 필요한 엔티티를 미리 로딩해두는 방법
    2. OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법
    
```
뷰가 필요한 엔티티를 미리 로딩 하는 방법
1. 글로벌 페치 전략 수정
2. JPQL 페치 조인
3. 강제 초기화
```

## What is (N+1) Error?
<u>글로벌 페치 전략에 즉시 로딩 시의 단점</u>중 하나로 조회한 order 엔티티가 10개면 member를 조회하는 SQL도 10번 실행하는 조회 중복 과정으로
조회 성능에 치명적 오류이므로 최적화가 필요하다.



### (N+1) Error 해결(JPQL 페치 조인)



### Container VS VM(가상 머신)


