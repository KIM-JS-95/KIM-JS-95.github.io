---
layout: post 
title:  "객체지향설계의 5대 원칙"
date:   2022-03-13 12:05:21 +0800 
tags: 면접 자바 SOLID
color: rgb(98,170,255)
subtitle: OOD 5대원칙
--- 

# 🚀 OOP를 올바르계 설계해 나가는 원칙
    
OOP의 4대 특성 `캡슐화`, `상속`, `추상화`, `다형성`은 객체지향 프로그래밍을 이어가는 동안 사용할 `Tool` 같은 역할아 된다.

도구가 있다면 용도에 맞게 사용해야하는데 요리를 하면 표준에 있듯이 OOP 세계에서도 원칙이라는 것이 존대한다.

`OOP`를 기반으로 설계하는 방식을 `OOD (Object Oriented Design)`이라고 하며 
설계 방법을 구체화 하여 정리한 원칙이 `SOLID`가 되는 것이다.

## 🌠  SOLID

원칙이 탄생한 것은 **높은 응집도와 낮은 결합도** 목표로 `로버트 C.마틴`이 확립한 개념이다.

### ☄ SRP(Single Responsibility Principle) : 단일 책임의 원칙

> "어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다."

![001](https://user-images.githubusercontent.com/65659478/158052296-f3c1ebf5-ef84-468b-b258-178f46957162.jpg)

하나의 클래스(남자)에 해야만 하는 역할이 너무다도 많다. 이 경우는 코드를 변경할 경우 복잡해지는 일이 발생할 것이다.

이 형태를 다음과 같이 바꾸면 그 역할히 더욱 이해하기 쉬워질 것이다.

![002](https://user-images.githubusercontent.com/65659478/158052294-4f8bbf14-c3a9-4835-ab19-c6c6bf4097c4.jpg)

이처럼 하나의 클래스에 `적합한 역할`을 구성하자는 원칙이 **단일 책임의 원칙**이 되는 것이다.

- 문제가 있는 코드
```java
public class 강아지 {
    final static Boolean 숫컷 = true;
    final static Boolean 암컷 = false;
    Boolean 성별;

    void 소변보다() {
        if (this.성별 == 숫컷) {
            // 한쪽 다리를 들고 소변을 본다.
        } else {
            // 뒤다리 두 개로 앉은 자세로 소변을 본다.
        }
    }
}
```

위 코드의 문제점을 찾아보면은 하나의 클래스에서 `소변보다()` 메소드가 암컷과 수컷의 행위를 모두 구현하는 것이 있다.

만일 더 많은 인스턴트가 존재할 경우 모든 변수에 대해 `if()`문을 구현한다면 코드는 **스파게티 코드** 가 될것이다.

**`SRP원칙`은 가정문을 사용하지 않고 클래스가 하나의 책임을 지는 것을 원칙으로 한다.**

- SRP 원칙을 확립한 코드
```java

public abstract class 강아지 {
    abstract void 소변보다();
}

public class 숫컷강아지 extends 강아지 {
	void 소변보다() {
		// 한쪽 다리를 들고 소변을 본다.
	}
}

public class 암컷강아지 extends 강아지 {
    void 소변보다() {
        // 뒤다리 두 개로 앉은 자세로 소변을 본다.
    }
}

```
개선된 코드는 `소변보다()`메소드를 클래스로 꺼내어 코드를 다루기 쉽도록 리팩토링하였다.


### ☄ OCP(Open Closed Principle) : 개방 폐쇄 원칙

> SW 엔티티(클래스, 모듈, 함수)는 확장에 대해서는 열려있어야 하며 변경에 대해서는 닫혀있어야한다.


`OCP`의 목적은 유연성, 재사용성, 유지보수성에 있다.

이것은 **인터페이스**의 목적에 대해 공부 했다면 빠르게 이해할 수 있을 것이다.

![004](https://user-images.githubusercontent.com/65659478/158052292-199ce24b-bcc0-49f5-a1fd-40fd801d5b0c.jpg)
![005](https://user-images.githubusercontent.com/65659478/158052293-4b1d49f2-f708-4597-ba78-80fe4edec67d.jpg)

우리가 차량을 바꾼다 해서 운전 방식이 완전히 달라지는 것은 아니다.

그림을 본다면 `자동`, `수동`에 차이만 있지만 엑셀을 밟고 핸들을 돌리는 행위는 변하지 않는다.
즉, 세세한 과정의 변화만 있을뿐 과정은 변하지 않는 것이다.

그렇다면 과정을 `추상화`하고 세세한 과정은 해당 차량의 클래스에서 담당 하도록 한다면
운전자는 `운전 행위`에 대해서는 영향을 받지 않게 된다.

![006](https://user-images.githubusercontent.com/65659478/158052291-55f3daed-8775-4635-821e-c5e787c7662a.jpg)

위 그림처럼 자동차의 공통부분을 `인터페이스`로 만들고 세세한 조작을 각 객체에 전담시킨다면 언제든 새로운 차량이 등장해도
우리는 인터페이스에서 상속받아 확장하기만 하면 되는 것이다.

### ☄ LSP(Liskov Substitution Principle) : 리스코프 치환 원칙

> 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야한다.
 
`LSP원칙`의 목적은 `교체`에 있다.

OOP에서의 상속은 `계층도` 혹은 `조직도`가 아닌 **분류도**가 되어야한다. 즉, 다음 원칙이 곧 `LSP원칙`의 기반이 되는 것이다.

- 하위 클래스는 상위 클래스의 한 종류이다.
- 구현 분류는 인터페이스할 수 있어야 한다.

![010](https://user-images.githubusercontent.com/65659478/158052839-97d8f198-d3d7-4397-a32a-20ab7975eb93.jpg)

```java
아버지 춘향이 = new 딸();
```

상위 클라스 역할의 아버지가 하위 클라스의 딸 에게 자신의 역할을 줄 수는 없다. 

춘향이는 아버지라는 객체의 참조 변수이지만 아버지의 메서드를 수행할 수는 없다.

![011](https://user-images.githubusercontent.com/65659478/158052840-a4039dc9-2684-4bf5-9f4b-859ca2ec8be9.jpg)

```java
동물 황제펭귄 = new 펭귄();
```

동물 객체의 하위 계층은 펭귄이 될 수 있으며 펭귄은 동물의 역할을 수행할 수 있다.
때문에 동물과 펭귄의 역할은 `LSP원칙`에 만족된다.

### ☄ ISP(Interface Segregation Principle) : 인터페이스 원칙

### ☄ DIP(Dependency Inversion Principle) : 의존 역전 원칙

## 🧾 Reference
- [깃헙 - 스프링 입문 교재](https://github.com/expert0226/oopinspring)
- [책 - 스프링을 입문을 위한 자바 객체 지향의 원리와 이해](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=55641908)



```java
![014](https://user-images.githubusercontent.com/65659478/158052844-0f0e8786-ba4b-4302-b1ce-e34095739882.jpg)
![012](https://user-images.githubusercontent.com/65659478/158052287-10f8fc87-c5f2-4574-8066-a6116aa38fe9.jpg)
![015](https://user-images.githubusercontent.com/65659478/158052289-3c202de7-ce17-451f-b55e-ec18b52f40f1.jpg)
![013](https://user-images.githubusercontent.com/65659478/158052290-41c3cd55-0edb-430f-b347-c1f3e86bc612.jpg)
```